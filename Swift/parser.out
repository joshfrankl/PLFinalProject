Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    FLOAT
    INT
    SQUOTE
    DOUBLE
    STRINGVALUE
    RBRACE
    BOOL
    LBRACE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> expression
Rule 5     statement -> variableDeclaration
Rule 6     statement -> variableReassignment
Rule 7     statement -> print
Rule 8     statement -> ifStatement
Rule 9     print -> PRINT LPAREN RPAREN
Rule 10    print -> PRINT LPAREN IDENTIFIER RPAREN
Rule 11    print -> PRINT LPAREN INTEGER RPAREN
Rule 12    print -> PRINT LPAREN decimal RPAREN
Rule 13    print -> PRINT LPAREN STRING RPAREN
Rule 14    variableReassignment -> IDENTIFIER EQUALS expression
Rule 15    variableReassignment -> IDENTIFIER PEQ expression
Rule 16    variableReassignment -> IDENTIFIER MEQ expression
Rule 17    variableReassignment -> IDENTIFIER MUEQ expression
Rule 18    variableReassignment -> IDENTIFIER DEQ expression
Rule 19    variableDeclaration -> VAR IDENTIFIER EQUALS expression
Rule 20    variableDeclaration -> LET IDENTIFIER EQUALS expression
Rule 21    ifStatement -> IF conditionalStatement codeBlock
Rule 22    ifStatement -> IF conditionalStatement codeBlock elseStatement
Rule 23    elseStatement -> ELSE codeBlock
Rule 24    elseStatement -> ifStatement
Rule 25    codeBlock -> LCURLY statements RCURLY
Rule 26    conditionalStatement -> item boolOP item
Rule 27    conditionalStatement -> TRUE
Rule 28    conditionalStatement -> FALSE
Rule 29    expression -> conjunction
Rule 30    expression -> conjunction OR_OP expression
Rule 31    conjunction -> equality
Rule 32    conjunction -> AND_OP equality
Rule 33    boolOP -> eqOP
Rule 34    boolOP -> relOP
Rule 35    equality -> relation
Rule 36    equality -> relation eqOP equality
Rule 37    eqOP -> EQ_OP
Rule 38    eqOP -> NE_OP
Rule 39    relation -> addition
Rule 40    relation -> addition relOP relation
Rule 41    relOP -> LT_OP
Rule 42    relOP -> LE_OP
Rule 43    relOP -> GT_OP
Rule 44    relOP -> GE_OP
Rule 45    addition -> term
Rule 46    addition -> term addOP addition
Rule 47    addOP -> PLUS
Rule 48    addOP -> MINUS
Rule 49    term -> factor
Rule 50    term -> factor mulOP term
Rule 51    mulOP -> MULT
Rule 52    mulOP -> DIV
Rule 53    mulOP -> MOD
Rule 54    factor -> primary
Rule 55    primary -> literal
Rule 56    literal -> INTEGER
Rule 57    literal -> decimal
Rule 58    literal -> STRING
Rule 59    literal -> IDENTIFIER
Rule 60    literal -> TRUE
Rule 61    literal -> FALSE
Rule 62    item -> INTEGER
Rule 63    item -> IDENTIFIER
Rule 64    item -> STRING
Rule 65    item -> decimal
Rule 66    decimal -> INTEGER . INTEGER
Rule 67    empty -> <empty>

Terminals, with rules where they appear

.                    : 66
AND_OP               : 32
BOOL                 : 
DEQ                  : 18
DIV                  : 52
DOUBLE               : 
ELSE                 : 23
EQUALS               : 14 19 20
EQ_OP                : 37
FALSE                : 28 61
FLOAT                : 
GE_OP                : 44
GT_OP                : 43
IDENTIFIER           : 10 14 15 16 17 18 19 20 59 63
IF                   : 21 22
INT                  : 
INTEGER              : 11 56 62 66 66
LBRACE               : 
LCURLY               : 25
LET                  : 20
LE_OP                : 42
LPAREN               : 9 10 11 12 13
LT_OP                : 41
MEQ                  : 16
MINUS                : 48
MOD                  : 53
MUEQ                 : 17
MULT                 : 51
NE_OP                : 38
OR_OP                : 30
PEQ                  : 15
PLUS                 : 47
PRINT                : 9 10 11 12 13
RBRACE               : 
RCURLY               : 25
RPAREN               : 9 10 11 12 13
SQUOTE               : 
STRING               : 13 58 64
STRINGVALUE          : 
TRUE                 : 27 60
VAR                  : 19
error                : 

Nonterminals, with rules where they appear

addOP                : 46
addition             : 39 40 46
boolOP               : 26
codeBlock            : 21 22 23
conditionalStatement : 21 22
conjunction          : 29 30
decimal              : 12 57 65
elseStatement        : 22
empty                : 
eqOP                 : 33 36
equality             : 31 32 36
expression           : 4 14 15 16 17 18 19 20 30
factor               : 49 50
ifStatement          : 8 24
item                 : 26 26
literal              : 55
mulOP                : 50
primary              : 54
print                : 7
program              : 0
relOP                : 34 40
relation             : 35 36 40
statement            : 2 3
statements           : 1 3 25
term                 : 45 46 50
variableDeclaration  : 5
variableReassignment : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . expression
    (5) statement -> . variableDeclaration
    (6) statement -> . variableReassignment
    (7) statement -> . print
    (8) statement -> . ifStatement
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (19) variableDeclaration -> . VAR IDENTIFIER EQUALS expression
    (20) variableDeclaration -> . LET IDENTIFIER EQUALS expression
    (14) variableReassignment -> . IDENTIFIER EQUALS expression
    (15) variableReassignment -> . IDENTIFIER PEQ expression
    (16) variableReassignment -> . IDENTIFIER MEQ expression
    (17) variableReassignment -> . IDENTIFIER MUEQ expression
    (18) variableReassignment -> . IDENTIFIER DEQ expression
    (9) print -> . PRINT LPAREN RPAREN
    (10) print -> . PRINT LPAREN IDENTIFIER RPAREN
    (11) print -> . PRINT LPAREN INTEGER RPAREN
    (12) print -> . PRINT LPAREN decimal RPAREN
    (13) print -> . PRINT LPAREN STRING RPAREN
    (21) ifStatement -> . IF conditionalStatement codeBlock
    (22) ifStatement -> . IF conditionalStatement codeBlock elseStatement
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    VAR             shift and go to state 3
    LET             shift and go to state 23
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 1
    IF              shift and go to state 13
    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    variableReassignment           shift and go to state 2
    statements                     shift and go to state 4
    program                        shift and go to state 5
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    statement                      shift and go to state 9
    term                           shift and go to state 10
    factor                         shift and go to state 12
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    expression                     shift and go to state 17
    ifStatement                    shift and go to state 19
    variableDeclaration            shift and go to state 20
    print                          shift and go to state 21
    decimal                        shift and go to state 25
    primary                        shift and go to state 27

state 1

    (9) print -> PRINT . LPAREN RPAREN
    (10) print -> PRINT . LPAREN IDENTIFIER RPAREN
    (11) print -> PRINT . LPAREN INTEGER RPAREN
    (12) print -> PRINT . LPAREN decimal RPAREN
    (13) print -> PRINT . LPAREN STRING RPAREN

    LPAREN          shift and go to state 28


state 2

    (6) statement -> variableReassignment .

    VAR             reduce using rule 6 (statement -> variableReassignment .)
    LET             reduce using rule 6 (statement -> variableReassignment .)
    IDENTIFIER      reduce using rule 6 (statement -> variableReassignment .)
    PRINT           reduce using rule 6 (statement -> variableReassignment .)
    IF              reduce using rule 6 (statement -> variableReassignment .)
    AND_OP          reduce using rule 6 (statement -> variableReassignment .)
    INTEGER         reduce using rule 6 (statement -> variableReassignment .)
    STRING          reduce using rule 6 (statement -> variableReassignment .)
    TRUE            reduce using rule 6 (statement -> variableReassignment .)
    FALSE           reduce using rule 6 (statement -> variableReassignment .)
    $end            reduce using rule 6 (statement -> variableReassignment .)
    RCURLY          reduce using rule 6 (statement -> variableReassignment .)


state 3

    (19) variableDeclaration -> VAR . IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 29


state 4

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . expression
    (5) statement -> . variableDeclaration
    (6) statement -> . variableReassignment
    (7) statement -> . print
    (8) statement -> . ifStatement
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (19) variableDeclaration -> . VAR IDENTIFIER EQUALS expression
    (20) variableDeclaration -> . LET IDENTIFIER EQUALS expression
    (14) variableReassignment -> . IDENTIFIER EQUALS expression
    (15) variableReassignment -> . IDENTIFIER PEQ expression
    (16) variableReassignment -> . IDENTIFIER MEQ expression
    (17) variableReassignment -> . IDENTIFIER MUEQ expression
    (18) variableReassignment -> . IDENTIFIER DEQ expression
    (9) print -> . PRINT LPAREN RPAREN
    (10) print -> . PRINT LPAREN IDENTIFIER RPAREN
    (11) print -> . PRINT LPAREN INTEGER RPAREN
    (12) print -> . PRINT LPAREN decimal RPAREN
    (13) print -> . PRINT LPAREN STRING RPAREN
    (21) ifStatement -> . IF conditionalStatement codeBlock
    (22) ifStatement -> . IF conditionalStatement codeBlock elseStatement
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    $end            reduce using rule 1 (program -> statements .)
    VAR             shift and go to state 3
    LET             shift and go to state 23
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 1
    IF              shift and go to state 13
    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    variableReassignment           shift and go to state 2
    expression                     shift and go to state 17
    ifStatement                    shift and go to state 19
    variableDeclaration            shift and go to state 20
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    print                          shift and go to state 21
    conjunction                    shift and go to state 8
    statement                      shift and go to state 30
    term                           shift and go to state 10
    decimal                        shift and go to state 25
    factor                         shift and go to state 12
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 5

    (0) S' -> program .



state 6

    (35) equality -> relation .
    (36) equality -> relation . eqOP equality
    (37) eqOP -> . EQ_OP
    (38) eqOP -> . NE_OP

    OR_OP           reduce using rule 35 (equality -> relation .)
    VAR             reduce using rule 35 (equality -> relation .)
    LET             reduce using rule 35 (equality -> relation .)
    IDENTIFIER      reduce using rule 35 (equality -> relation .)
    PRINT           reduce using rule 35 (equality -> relation .)
    IF              reduce using rule 35 (equality -> relation .)
    AND_OP          reduce using rule 35 (equality -> relation .)
    INTEGER         reduce using rule 35 (equality -> relation .)
    STRING          reduce using rule 35 (equality -> relation .)
    TRUE            reduce using rule 35 (equality -> relation .)
    FALSE           reduce using rule 35 (equality -> relation .)
    $end            reduce using rule 35 (equality -> relation .)
    RCURLY          reduce using rule 35 (equality -> relation .)
    EQ_OP           shift and go to state 33
    NE_OP           shift and go to state 32

    eqOP                           shift and go to state 31

state 7

    (55) primary -> literal .

    MULT            reduce using rule 55 (primary -> literal .)
    DIV             reduce using rule 55 (primary -> literal .)
    MOD             reduce using rule 55 (primary -> literal .)
    PLUS            reduce using rule 55 (primary -> literal .)
    MINUS           reduce using rule 55 (primary -> literal .)
    LT_OP           reduce using rule 55 (primary -> literal .)
    LE_OP           reduce using rule 55 (primary -> literal .)
    GT_OP           reduce using rule 55 (primary -> literal .)
    GE_OP           reduce using rule 55 (primary -> literal .)
    EQ_OP           reduce using rule 55 (primary -> literal .)
    NE_OP           reduce using rule 55 (primary -> literal .)
    OR_OP           reduce using rule 55 (primary -> literal .)
    VAR             reduce using rule 55 (primary -> literal .)
    LET             reduce using rule 55 (primary -> literal .)
    IDENTIFIER      reduce using rule 55 (primary -> literal .)
    PRINT           reduce using rule 55 (primary -> literal .)
    IF              reduce using rule 55 (primary -> literal .)
    AND_OP          reduce using rule 55 (primary -> literal .)
    INTEGER         reduce using rule 55 (primary -> literal .)
    STRING          reduce using rule 55 (primary -> literal .)
    TRUE            reduce using rule 55 (primary -> literal .)
    FALSE           reduce using rule 55 (primary -> literal .)
    $end            reduce using rule 55 (primary -> literal .)
    RCURLY          reduce using rule 55 (primary -> literal .)


state 8

    (29) expression -> conjunction .
    (30) expression -> conjunction . OR_OP expression

    VAR             reduce using rule 29 (expression -> conjunction .)
    LET             reduce using rule 29 (expression -> conjunction .)
    IDENTIFIER      reduce using rule 29 (expression -> conjunction .)
    PRINT           reduce using rule 29 (expression -> conjunction .)
    IF              reduce using rule 29 (expression -> conjunction .)
    AND_OP          reduce using rule 29 (expression -> conjunction .)
    INTEGER         reduce using rule 29 (expression -> conjunction .)
    STRING          reduce using rule 29 (expression -> conjunction .)
    TRUE            reduce using rule 29 (expression -> conjunction .)
    FALSE           reduce using rule 29 (expression -> conjunction .)
    $end            reduce using rule 29 (expression -> conjunction .)
    RCURLY          reduce using rule 29 (expression -> conjunction .)
    OR_OP           shift and go to state 34


state 9

    (2) statements -> statement .

    VAR             reduce using rule 2 (statements -> statement .)
    LET             reduce using rule 2 (statements -> statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    AND_OP          reduce using rule 2 (statements -> statement .)
    INTEGER         reduce using rule 2 (statements -> statement .)
    STRING          reduce using rule 2 (statements -> statement .)
    TRUE            reduce using rule 2 (statements -> statement .)
    FALSE           reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    RCURLY          reduce using rule 2 (statements -> statement .)


state 10

    (45) addition -> term .
    (46) addition -> term . addOP addition
    (47) addOP -> . PLUS
    (48) addOP -> . MINUS

    LT_OP           reduce using rule 45 (addition -> term .)
    LE_OP           reduce using rule 45 (addition -> term .)
    GT_OP           reduce using rule 45 (addition -> term .)
    GE_OP           reduce using rule 45 (addition -> term .)
    EQ_OP           reduce using rule 45 (addition -> term .)
    NE_OP           reduce using rule 45 (addition -> term .)
    OR_OP           reduce using rule 45 (addition -> term .)
    VAR             reduce using rule 45 (addition -> term .)
    LET             reduce using rule 45 (addition -> term .)
    IDENTIFIER      reduce using rule 45 (addition -> term .)
    PRINT           reduce using rule 45 (addition -> term .)
    IF              reduce using rule 45 (addition -> term .)
    AND_OP          reduce using rule 45 (addition -> term .)
    INTEGER         reduce using rule 45 (addition -> term .)
    STRING          reduce using rule 45 (addition -> term .)
    TRUE            reduce using rule 45 (addition -> term .)
    FALSE           reduce using rule 45 (addition -> term .)
    $end            reduce using rule 45 (addition -> term .)
    RCURLY          reduce using rule 45 (addition -> term .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 36

    addOP                          shift and go to state 35

state 11

    (14) variableReassignment -> IDENTIFIER . EQUALS expression
    (15) variableReassignment -> IDENTIFIER . PEQ expression
    (16) variableReassignment -> IDENTIFIER . MEQ expression
    (17) variableReassignment -> IDENTIFIER . MUEQ expression
    (18) variableReassignment -> IDENTIFIER . DEQ expression
    (59) literal -> IDENTIFIER .

    EQUALS          shift and go to state 38
    PEQ             shift and go to state 42
    MEQ             shift and go to state 41
    MUEQ            shift and go to state 39
    DEQ             shift and go to state 40
    MULT            reduce using rule 59 (literal -> IDENTIFIER .)
    DIV             reduce using rule 59 (literal -> IDENTIFIER .)
    MOD             reduce using rule 59 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 59 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 59 (literal -> IDENTIFIER .)
    LT_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    LE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    GT_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    GE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    EQ_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    NE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    OR_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    VAR             reduce using rule 59 (literal -> IDENTIFIER .)
    LET             reduce using rule 59 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 59 (literal -> IDENTIFIER .)
    PRINT           reduce using rule 59 (literal -> IDENTIFIER .)
    IF              reduce using rule 59 (literal -> IDENTIFIER .)
    AND_OP          reduce using rule 59 (literal -> IDENTIFIER .)
    INTEGER         reduce using rule 59 (literal -> IDENTIFIER .)
    STRING          reduce using rule 59 (literal -> IDENTIFIER .)
    TRUE            reduce using rule 59 (literal -> IDENTIFIER .)
    FALSE           reduce using rule 59 (literal -> IDENTIFIER .)
    $end            reduce using rule 59 (literal -> IDENTIFIER .)
    RCURLY          reduce using rule 59 (literal -> IDENTIFIER .)


state 12

    (49) term -> factor .
    (50) term -> factor . mulOP term
    (51) mulOP -> . MULT
    (52) mulOP -> . DIV
    (53) mulOP -> . MOD

    PLUS            reduce using rule 49 (term -> factor .)
    MINUS           reduce using rule 49 (term -> factor .)
    LT_OP           reduce using rule 49 (term -> factor .)
    LE_OP           reduce using rule 49 (term -> factor .)
    GT_OP           reduce using rule 49 (term -> factor .)
    GE_OP           reduce using rule 49 (term -> factor .)
    EQ_OP           reduce using rule 49 (term -> factor .)
    NE_OP           reduce using rule 49 (term -> factor .)
    OR_OP           reduce using rule 49 (term -> factor .)
    VAR             reduce using rule 49 (term -> factor .)
    LET             reduce using rule 49 (term -> factor .)
    IDENTIFIER      reduce using rule 49 (term -> factor .)
    PRINT           reduce using rule 49 (term -> factor .)
    IF              reduce using rule 49 (term -> factor .)
    AND_OP          reduce using rule 49 (term -> factor .)
    INTEGER         reduce using rule 49 (term -> factor .)
    STRING          reduce using rule 49 (term -> factor .)
    TRUE            reduce using rule 49 (term -> factor .)
    FALSE           reduce using rule 49 (term -> factor .)
    $end            reduce using rule 49 (term -> factor .)
    RCURLY          reduce using rule 49 (term -> factor .)
    MULT            shift and go to state 46
    DIV             shift and go to state 44
    MOD             shift and go to state 43

    mulOP                          shift and go to state 45

state 13

    (21) ifStatement -> IF . conditionalStatement codeBlock
    (22) ifStatement -> IF . conditionalStatement codeBlock elseStatement
    (26) conditionalStatement -> . item boolOP item
    (27) conditionalStatement -> . TRUE
    (28) conditionalStatement -> . FALSE
    (62) item -> . INTEGER
    (63) item -> . IDENTIFIER
    (64) item -> . STRING
    (65) item -> . decimal
    (66) decimal -> . INTEGER . INTEGER

    TRUE            shift and go to state 49
    FALSE           shift and go to state 51
    INTEGER         shift and go to state 54
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 50

    conditionalStatement           shift and go to state 47
    item                           shift and go to state 48
    decimal                        shift and go to state 53

state 14

    (31) conjunction -> equality .

    OR_OP           reduce using rule 31 (conjunction -> equality .)
    VAR             reduce using rule 31 (conjunction -> equality .)
    LET             reduce using rule 31 (conjunction -> equality .)
    IDENTIFIER      reduce using rule 31 (conjunction -> equality .)
    PRINT           reduce using rule 31 (conjunction -> equality .)
    IF              reduce using rule 31 (conjunction -> equality .)
    AND_OP          reduce using rule 31 (conjunction -> equality .)
    INTEGER         reduce using rule 31 (conjunction -> equality .)
    STRING          reduce using rule 31 (conjunction -> equality .)
    TRUE            reduce using rule 31 (conjunction -> equality .)
    FALSE           reduce using rule 31 (conjunction -> equality .)
    $end            reduce using rule 31 (conjunction -> equality .)
    RCURLY          reduce using rule 31 (conjunction -> equality .)


state 15

    (56) literal -> INTEGER .
    (66) decimal -> INTEGER . . INTEGER

    MULT            reduce using rule 56 (literal -> INTEGER .)
    DIV             reduce using rule 56 (literal -> INTEGER .)
    MOD             reduce using rule 56 (literal -> INTEGER .)
    PLUS            reduce using rule 56 (literal -> INTEGER .)
    MINUS           reduce using rule 56 (literal -> INTEGER .)
    LT_OP           reduce using rule 56 (literal -> INTEGER .)
    LE_OP           reduce using rule 56 (literal -> INTEGER .)
    GT_OP           reduce using rule 56 (literal -> INTEGER .)
    GE_OP           reduce using rule 56 (literal -> INTEGER .)
    EQ_OP           reduce using rule 56 (literal -> INTEGER .)
    NE_OP           reduce using rule 56 (literal -> INTEGER .)
    OR_OP           reduce using rule 56 (literal -> INTEGER .)
    VAR             reduce using rule 56 (literal -> INTEGER .)
    LET             reduce using rule 56 (literal -> INTEGER .)
    IDENTIFIER      reduce using rule 56 (literal -> INTEGER .)
    PRINT           reduce using rule 56 (literal -> INTEGER .)
    IF              reduce using rule 56 (literal -> INTEGER .)
    AND_OP          reduce using rule 56 (literal -> INTEGER .)
    INTEGER         reduce using rule 56 (literal -> INTEGER .)
    STRING          reduce using rule 56 (literal -> INTEGER .)
    TRUE            reduce using rule 56 (literal -> INTEGER .)
    FALSE           reduce using rule 56 (literal -> INTEGER .)
    $end            reduce using rule 56 (literal -> INTEGER .)
    RCURLY          reduce using rule 56 (literal -> INTEGER .)
    .               shift and go to state 55


state 16

    (39) relation -> addition .
    (40) relation -> addition . relOP relation
    (41) relOP -> . LT_OP
    (42) relOP -> . LE_OP
    (43) relOP -> . GT_OP
    (44) relOP -> . GE_OP

    EQ_OP           reduce using rule 39 (relation -> addition .)
    NE_OP           reduce using rule 39 (relation -> addition .)
    OR_OP           reduce using rule 39 (relation -> addition .)
    VAR             reduce using rule 39 (relation -> addition .)
    LET             reduce using rule 39 (relation -> addition .)
    IDENTIFIER      reduce using rule 39 (relation -> addition .)
    PRINT           reduce using rule 39 (relation -> addition .)
    IF              reduce using rule 39 (relation -> addition .)
    AND_OP          reduce using rule 39 (relation -> addition .)
    INTEGER         reduce using rule 39 (relation -> addition .)
    STRING          reduce using rule 39 (relation -> addition .)
    TRUE            reduce using rule 39 (relation -> addition .)
    FALSE           reduce using rule 39 (relation -> addition .)
    $end            reduce using rule 39 (relation -> addition .)
    RCURLY          reduce using rule 39 (relation -> addition .)
    LT_OP           shift and go to state 60
    LE_OP           shift and go to state 57
    GT_OP           shift and go to state 56
    GE_OP           shift and go to state 58

    relOP                          shift and go to state 59

state 17

    (4) statement -> expression .

    VAR             reduce using rule 4 (statement -> expression .)
    LET             reduce using rule 4 (statement -> expression .)
    IDENTIFIER      reduce using rule 4 (statement -> expression .)
    PRINT           reduce using rule 4 (statement -> expression .)
    IF              reduce using rule 4 (statement -> expression .)
    AND_OP          reduce using rule 4 (statement -> expression .)
    INTEGER         reduce using rule 4 (statement -> expression .)
    STRING          reduce using rule 4 (statement -> expression .)
    TRUE            reduce using rule 4 (statement -> expression .)
    FALSE           reduce using rule 4 (statement -> expression .)
    $end            reduce using rule 4 (statement -> expression .)
    RCURLY          reduce using rule 4 (statement -> expression .)


state 18

    (60) literal -> TRUE .

    MULT            reduce using rule 60 (literal -> TRUE .)
    DIV             reduce using rule 60 (literal -> TRUE .)
    MOD             reduce using rule 60 (literal -> TRUE .)
    PLUS            reduce using rule 60 (literal -> TRUE .)
    MINUS           reduce using rule 60 (literal -> TRUE .)
    LT_OP           reduce using rule 60 (literal -> TRUE .)
    LE_OP           reduce using rule 60 (literal -> TRUE .)
    GT_OP           reduce using rule 60 (literal -> TRUE .)
    GE_OP           reduce using rule 60 (literal -> TRUE .)
    EQ_OP           reduce using rule 60 (literal -> TRUE .)
    NE_OP           reduce using rule 60 (literal -> TRUE .)
    OR_OP           reduce using rule 60 (literal -> TRUE .)
    VAR             reduce using rule 60 (literal -> TRUE .)
    LET             reduce using rule 60 (literal -> TRUE .)
    IDENTIFIER      reduce using rule 60 (literal -> TRUE .)
    PRINT           reduce using rule 60 (literal -> TRUE .)
    IF              reduce using rule 60 (literal -> TRUE .)
    AND_OP          reduce using rule 60 (literal -> TRUE .)
    INTEGER         reduce using rule 60 (literal -> TRUE .)
    STRING          reduce using rule 60 (literal -> TRUE .)
    TRUE            reduce using rule 60 (literal -> TRUE .)
    FALSE           reduce using rule 60 (literal -> TRUE .)
    $end            reduce using rule 60 (literal -> TRUE .)
    RCURLY          reduce using rule 60 (literal -> TRUE .)


state 19

    (8) statement -> ifStatement .

    VAR             reduce using rule 8 (statement -> ifStatement .)
    LET             reduce using rule 8 (statement -> ifStatement .)
    IDENTIFIER      reduce using rule 8 (statement -> ifStatement .)
    PRINT           reduce using rule 8 (statement -> ifStatement .)
    IF              reduce using rule 8 (statement -> ifStatement .)
    AND_OP          reduce using rule 8 (statement -> ifStatement .)
    INTEGER         reduce using rule 8 (statement -> ifStatement .)
    STRING          reduce using rule 8 (statement -> ifStatement .)
    TRUE            reduce using rule 8 (statement -> ifStatement .)
    FALSE           reduce using rule 8 (statement -> ifStatement .)
    $end            reduce using rule 8 (statement -> ifStatement .)
    RCURLY          reduce using rule 8 (statement -> ifStatement .)


state 20

    (5) statement -> variableDeclaration .

    VAR             reduce using rule 5 (statement -> variableDeclaration .)
    LET             reduce using rule 5 (statement -> variableDeclaration .)
    IDENTIFIER      reduce using rule 5 (statement -> variableDeclaration .)
    PRINT           reduce using rule 5 (statement -> variableDeclaration .)
    IF              reduce using rule 5 (statement -> variableDeclaration .)
    AND_OP          reduce using rule 5 (statement -> variableDeclaration .)
    INTEGER         reduce using rule 5 (statement -> variableDeclaration .)
    STRING          reduce using rule 5 (statement -> variableDeclaration .)
    TRUE            reduce using rule 5 (statement -> variableDeclaration .)
    FALSE           reduce using rule 5 (statement -> variableDeclaration .)
    $end            reduce using rule 5 (statement -> variableDeclaration .)
    RCURLY          reduce using rule 5 (statement -> variableDeclaration .)


state 21

    (7) statement -> print .

    VAR             reduce using rule 7 (statement -> print .)
    LET             reduce using rule 7 (statement -> print .)
    IDENTIFIER      reduce using rule 7 (statement -> print .)
    PRINT           reduce using rule 7 (statement -> print .)
    IF              reduce using rule 7 (statement -> print .)
    AND_OP          reduce using rule 7 (statement -> print .)
    INTEGER         reduce using rule 7 (statement -> print .)
    STRING          reduce using rule 7 (statement -> print .)
    TRUE            reduce using rule 7 (statement -> print .)
    FALSE           reduce using rule 7 (statement -> print .)
    $end            reduce using rule 7 (statement -> print .)
    RCURLY          reduce using rule 7 (statement -> print .)


state 22

    (58) literal -> STRING .

    MULT            reduce using rule 58 (literal -> STRING .)
    DIV             reduce using rule 58 (literal -> STRING .)
    MOD             reduce using rule 58 (literal -> STRING .)
    PLUS            reduce using rule 58 (literal -> STRING .)
    MINUS           reduce using rule 58 (literal -> STRING .)
    LT_OP           reduce using rule 58 (literal -> STRING .)
    LE_OP           reduce using rule 58 (literal -> STRING .)
    GT_OP           reduce using rule 58 (literal -> STRING .)
    GE_OP           reduce using rule 58 (literal -> STRING .)
    EQ_OP           reduce using rule 58 (literal -> STRING .)
    NE_OP           reduce using rule 58 (literal -> STRING .)
    OR_OP           reduce using rule 58 (literal -> STRING .)
    VAR             reduce using rule 58 (literal -> STRING .)
    LET             reduce using rule 58 (literal -> STRING .)
    IDENTIFIER      reduce using rule 58 (literal -> STRING .)
    PRINT           reduce using rule 58 (literal -> STRING .)
    IF              reduce using rule 58 (literal -> STRING .)
    AND_OP          reduce using rule 58 (literal -> STRING .)
    INTEGER         reduce using rule 58 (literal -> STRING .)
    STRING          reduce using rule 58 (literal -> STRING .)
    TRUE            reduce using rule 58 (literal -> STRING .)
    FALSE           reduce using rule 58 (literal -> STRING .)
    $end            reduce using rule 58 (literal -> STRING .)
    RCURLY          reduce using rule 58 (literal -> STRING .)


state 23

    (20) variableDeclaration -> LET . IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 61


state 24

    (61) literal -> FALSE .

    MULT            reduce using rule 61 (literal -> FALSE .)
    DIV             reduce using rule 61 (literal -> FALSE .)
    MOD             reduce using rule 61 (literal -> FALSE .)
    PLUS            reduce using rule 61 (literal -> FALSE .)
    MINUS           reduce using rule 61 (literal -> FALSE .)
    LT_OP           reduce using rule 61 (literal -> FALSE .)
    LE_OP           reduce using rule 61 (literal -> FALSE .)
    GT_OP           reduce using rule 61 (literal -> FALSE .)
    GE_OP           reduce using rule 61 (literal -> FALSE .)
    EQ_OP           reduce using rule 61 (literal -> FALSE .)
    NE_OP           reduce using rule 61 (literal -> FALSE .)
    OR_OP           reduce using rule 61 (literal -> FALSE .)
    VAR             reduce using rule 61 (literal -> FALSE .)
    LET             reduce using rule 61 (literal -> FALSE .)
    IDENTIFIER      reduce using rule 61 (literal -> FALSE .)
    PRINT           reduce using rule 61 (literal -> FALSE .)
    IF              reduce using rule 61 (literal -> FALSE .)
    AND_OP          reduce using rule 61 (literal -> FALSE .)
    INTEGER         reduce using rule 61 (literal -> FALSE .)
    STRING          reduce using rule 61 (literal -> FALSE .)
    TRUE            reduce using rule 61 (literal -> FALSE .)
    FALSE           reduce using rule 61 (literal -> FALSE .)
    $end            reduce using rule 61 (literal -> FALSE .)
    RCURLY          reduce using rule 61 (literal -> FALSE .)


state 25

    (57) literal -> decimal .

    MULT            reduce using rule 57 (literal -> decimal .)
    DIV             reduce using rule 57 (literal -> decimal .)
    MOD             reduce using rule 57 (literal -> decimal .)
    PLUS            reduce using rule 57 (literal -> decimal .)
    MINUS           reduce using rule 57 (literal -> decimal .)
    LT_OP           reduce using rule 57 (literal -> decimal .)
    LE_OP           reduce using rule 57 (literal -> decimal .)
    GT_OP           reduce using rule 57 (literal -> decimal .)
    GE_OP           reduce using rule 57 (literal -> decimal .)
    EQ_OP           reduce using rule 57 (literal -> decimal .)
    NE_OP           reduce using rule 57 (literal -> decimal .)
    OR_OP           reduce using rule 57 (literal -> decimal .)
    VAR             reduce using rule 57 (literal -> decimal .)
    LET             reduce using rule 57 (literal -> decimal .)
    IDENTIFIER      reduce using rule 57 (literal -> decimal .)
    PRINT           reduce using rule 57 (literal -> decimal .)
    IF              reduce using rule 57 (literal -> decimal .)
    AND_OP          reduce using rule 57 (literal -> decimal .)
    INTEGER         reduce using rule 57 (literal -> decimal .)
    STRING          reduce using rule 57 (literal -> decimal .)
    TRUE            reduce using rule 57 (literal -> decimal .)
    FALSE           reduce using rule 57 (literal -> decimal .)
    $end            reduce using rule 57 (literal -> decimal .)
    RCURLY          reduce using rule 57 (literal -> decimal .)


state 26

    (32) conjunction -> AND_OP . equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    relation                       shift and go to state 6
    literal                        shift and go to state 7
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 63
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 27

    (54) factor -> primary .

    MULT            reduce using rule 54 (factor -> primary .)
    DIV             reduce using rule 54 (factor -> primary .)
    MOD             reduce using rule 54 (factor -> primary .)
    PLUS            reduce using rule 54 (factor -> primary .)
    MINUS           reduce using rule 54 (factor -> primary .)
    LT_OP           reduce using rule 54 (factor -> primary .)
    LE_OP           reduce using rule 54 (factor -> primary .)
    GT_OP           reduce using rule 54 (factor -> primary .)
    GE_OP           reduce using rule 54 (factor -> primary .)
    EQ_OP           reduce using rule 54 (factor -> primary .)
    NE_OP           reduce using rule 54 (factor -> primary .)
    OR_OP           reduce using rule 54 (factor -> primary .)
    RCURLY          reduce using rule 54 (factor -> primary .)
    VAR             reduce using rule 54 (factor -> primary .)
    LET             reduce using rule 54 (factor -> primary .)
    IDENTIFIER      reduce using rule 54 (factor -> primary .)
    PRINT           reduce using rule 54 (factor -> primary .)
    IF              reduce using rule 54 (factor -> primary .)
    AND_OP          reduce using rule 54 (factor -> primary .)
    INTEGER         reduce using rule 54 (factor -> primary .)
    STRING          reduce using rule 54 (factor -> primary .)
    TRUE            reduce using rule 54 (factor -> primary .)
    FALSE           reduce using rule 54 (factor -> primary .)
    $end            reduce using rule 54 (factor -> primary .)


state 28

    (9) print -> PRINT LPAREN . RPAREN
    (10) print -> PRINT LPAREN . IDENTIFIER RPAREN
    (11) print -> PRINT LPAREN . INTEGER RPAREN
    (12) print -> PRINT LPAREN . decimal RPAREN
    (13) print -> PRINT LPAREN . STRING RPAREN
    (66) decimal -> . INTEGER . INTEGER

    RPAREN          shift and go to state 64
    IDENTIFIER      shift and go to state 66
    INTEGER         shift and go to state 68
    STRING          shift and go to state 65

    decimal                        shift and go to state 67

state 29

    (19) variableDeclaration -> VAR IDENTIFIER . EQUALS expression

    EQUALS          shift and go to state 69


state 30

    (3) statements -> statements statement .

    VAR             reduce using rule 3 (statements -> statements statement .)
    LET             reduce using rule 3 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    AND_OP          reduce using rule 3 (statements -> statements statement .)
    INTEGER         reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    TRUE            reduce using rule 3 (statements -> statements statement .)
    FALSE           reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    RCURLY          reduce using rule 3 (statements -> statements statement .)


state 31

    (36) equality -> relation eqOP . equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    relation                       shift and go to state 6
    literal                        shift and go to state 7
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 70
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 32

    (38) eqOP -> NE_OP .

    INTEGER         reduce using rule 38 (eqOP -> NE_OP .)
    IDENTIFIER      reduce using rule 38 (eqOP -> NE_OP .)
    STRING          reduce using rule 38 (eqOP -> NE_OP .)
    TRUE            reduce using rule 38 (eqOP -> NE_OP .)
    FALSE           reduce using rule 38 (eqOP -> NE_OP .)


state 33

    (37) eqOP -> EQ_OP .

    INTEGER         reduce using rule 37 (eqOP -> EQ_OP .)
    IDENTIFIER      reduce using rule 37 (eqOP -> EQ_OP .)
    STRING          reduce using rule 37 (eqOP -> EQ_OP .)
    TRUE            reduce using rule 37 (eqOP -> EQ_OP .)
    FALSE           reduce using rule 37 (eqOP -> EQ_OP .)


state 34

    (30) expression -> conjunction OR_OP . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 71
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 35

    (46) addition -> term addOP . addition
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    literal                        shift and go to state 7
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    addition                       shift and go to state 72
    primary                        shift and go to state 27

state 36

    (48) addOP -> MINUS .

    INTEGER         reduce using rule 48 (addOP -> MINUS .)
    STRING          reduce using rule 48 (addOP -> MINUS .)
    IDENTIFIER      reduce using rule 48 (addOP -> MINUS .)
    TRUE            reduce using rule 48 (addOP -> MINUS .)
    FALSE           reduce using rule 48 (addOP -> MINUS .)


state 37

    (47) addOP -> PLUS .

    INTEGER         reduce using rule 47 (addOP -> PLUS .)
    STRING          reduce using rule 47 (addOP -> PLUS .)
    IDENTIFIER      reduce using rule 47 (addOP -> PLUS .)
    TRUE            reduce using rule 47 (addOP -> PLUS .)
    FALSE           reduce using rule 47 (addOP -> PLUS .)


state 38

    (14) variableReassignment -> IDENTIFIER EQUALS . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 73
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 39

    (17) variableReassignment -> IDENTIFIER MUEQ . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 74
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 40

    (18) variableReassignment -> IDENTIFIER DEQ . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 75
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 41

    (16) variableReassignment -> IDENTIFIER MEQ . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 76
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 42

    (15) variableReassignment -> IDENTIFIER PEQ . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 77
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 43

    (53) mulOP -> MOD .

    INTEGER         reduce using rule 53 (mulOP -> MOD .)
    STRING          reduce using rule 53 (mulOP -> MOD .)
    IDENTIFIER      reduce using rule 53 (mulOP -> MOD .)
    TRUE            reduce using rule 53 (mulOP -> MOD .)
    FALSE           reduce using rule 53 (mulOP -> MOD .)


state 44

    (52) mulOP -> DIV .

    INTEGER         reduce using rule 52 (mulOP -> DIV .)
    STRING          reduce using rule 52 (mulOP -> DIV .)
    IDENTIFIER      reduce using rule 52 (mulOP -> DIV .)
    TRUE            reduce using rule 52 (mulOP -> DIV .)
    FALSE           reduce using rule 52 (mulOP -> DIV .)


state 45

    (50) term -> factor mulOP . term
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    literal                        shift and go to state 7
    term                           shift and go to state 78
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    primary                        shift and go to state 27

state 46

    (51) mulOP -> MULT .

    INTEGER         reduce using rule 51 (mulOP -> MULT .)
    STRING          reduce using rule 51 (mulOP -> MULT .)
    IDENTIFIER      reduce using rule 51 (mulOP -> MULT .)
    TRUE            reduce using rule 51 (mulOP -> MULT .)
    FALSE           reduce using rule 51 (mulOP -> MULT .)


state 47

    (21) ifStatement -> IF conditionalStatement . codeBlock
    (22) ifStatement -> IF conditionalStatement . codeBlock elseStatement
    (25) codeBlock -> . LCURLY statements RCURLY

    LCURLY          shift and go to state 79

    codeBlock                      shift and go to state 80

state 48

    (26) conditionalStatement -> item . boolOP item
    (33) boolOP -> . eqOP
    (34) boolOP -> . relOP
    (37) eqOP -> . EQ_OP
    (38) eqOP -> . NE_OP
    (41) relOP -> . LT_OP
    (42) relOP -> . LE_OP
    (43) relOP -> . GT_OP
    (44) relOP -> . GE_OP

    EQ_OP           shift and go to state 33
    NE_OP           shift and go to state 32
    LT_OP           shift and go to state 60
    LE_OP           shift and go to state 57
    GT_OP           shift and go to state 56
    GE_OP           shift and go to state 58

    boolOP                         shift and go to state 81
    eqOP                           shift and go to state 82
    relOP                          shift and go to state 83

state 49

    (27) conditionalStatement -> TRUE .

    LCURLY          reduce using rule 27 (conditionalStatement -> TRUE .)


state 50

    (64) item -> STRING .

    EQ_OP           reduce using rule 64 (item -> STRING .)
    NE_OP           reduce using rule 64 (item -> STRING .)
    LT_OP           reduce using rule 64 (item -> STRING .)
    LE_OP           reduce using rule 64 (item -> STRING .)
    GT_OP           reduce using rule 64 (item -> STRING .)
    GE_OP           reduce using rule 64 (item -> STRING .)
    LCURLY          reduce using rule 64 (item -> STRING .)


state 51

    (28) conditionalStatement -> FALSE .

    LCURLY          reduce using rule 28 (conditionalStatement -> FALSE .)


state 52

    (63) item -> IDENTIFIER .

    EQ_OP           reduce using rule 63 (item -> IDENTIFIER .)
    NE_OP           reduce using rule 63 (item -> IDENTIFIER .)
    LT_OP           reduce using rule 63 (item -> IDENTIFIER .)
    LE_OP           reduce using rule 63 (item -> IDENTIFIER .)
    GT_OP           reduce using rule 63 (item -> IDENTIFIER .)
    GE_OP           reduce using rule 63 (item -> IDENTIFIER .)
    LCURLY          reduce using rule 63 (item -> IDENTIFIER .)


state 53

    (65) item -> decimal .

    EQ_OP           reduce using rule 65 (item -> decimal .)
    NE_OP           reduce using rule 65 (item -> decimal .)
    LT_OP           reduce using rule 65 (item -> decimal .)
    LE_OP           reduce using rule 65 (item -> decimal .)
    GT_OP           reduce using rule 65 (item -> decimal .)
    GE_OP           reduce using rule 65 (item -> decimal .)
    LCURLY          reduce using rule 65 (item -> decimal .)


state 54

    (62) item -> INTEGER .
    (66) decimal -> INTEGER . . INTEGER

    EQ_OP           reduce using rule 62 (item -> INTEGER .)
    NE_OP           reduce using rule 62 (item -> INTEGER .)
    LT_OP           reduce using rule 62 (item -> INTEGER .)
    LE_OP           reduce using rule 62 (item -> INTEGER .)
    GT_OP           reduce using rule 62 (item -> INTEGER .)
    GE_OP           reduce using rule 62 (item -> INTEGER .)
    LCURLY          reduce using rule 62 (item -> INTEGER .)
    .               shift and go to state 55


state 55

    (66) decimal -> INTEGER . . INTEGER

    INTEGER         shift and go to state 84


state 56

    (43) relOP -> GT_OP .

    INTEGER         reduce using rule 43 (relOP -> GT_OP .)
    STRING          reduce using rule 43 (relOP -> GT_OP .)
    IDENTIFIER      reduce using rule 43 (relOP -> GT_OP .)
    TRUE            reduce using rule 43 (relOP -> GT_OP .)
    FALSE           reduce using rule 43 (relOP -> GT_OP .)


state 57

    (42) relOP -> LE_OP .

    INTEGER         reduce using rule 42 (relOP -> LE_OP .)
    STRING          reduce using rule 42 (relOP -> LE_OP .)
    IDENTIFIER      reduce using rule 42 (relOP -> LE_OP .)
    TRUE            reduce using rule 42 (relOP -> LE_OP .)
    FALSE           reduce using rule 42 (relOP -> LE_OP .)


state 58

    (44) relOP -> GE_OP .

    INTEGER         reduce using rule 44 (relOP -> GE_OP .)
    STRING          reduce using rule 44 (relOP -> GE_OP .)
    IDENTIFIER      reduce using rule 44 (relOP -> GE_OP .)
    TRUE            reduce using rule 44 (relOP -> GE_OP .)
    FALSE           reduce using rule 44 (relOP -> GE_OP .)


state 59

    (40) relation -> addition relOP . relation
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    relation                       shift and go to state 85
    literal                        shift and go to state 7
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 60

    (41) relOP -> LT_OP .

    INTEGER         reduce using rule 41 (relOP -> LT_OP .)
    STRING          reduce using rule 41 (relOP -> LT_OP .)
    IDENTIFIER      reduce using rule 41 (relOP -> LT_OP .)
    TRUE            reduce using rule 41 (relOP -> LT_OP .)
    FALSE           reduce using rule 41 (relOP -> LT_OP .)


state 61

    (20) variableDeclaration -> LET IDENTIFIER . EQUALS expression

    EQUALS          shift and go to state 86


state 62

    (59) literal -> IDENTIFIER .

    MULT            reduce using rule 59 (literal -> IDENTIFIER .)
    DIV             reduce using rule 59 (literal -> IDENTIFIER .)
    MOD             reduce using rule 59 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 59 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 59 (literal -> IDENTIFIER .)
    LT_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    LE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    GT_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    GE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    EQ_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    NE_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    OR_OP           reduce using rule 59 (literal -> IDENTIFIER .)
    VAR             reduce using rule 59 (literal -> IDENTIFIER .)
    LET             reduce using rule 59 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 59 (literal -> IDENTIFIER .)
    PRINT           reduce using rule 59 (literal -> IDENTIFIER .)
    IF              reduce using rule 59 (literal -> IDENTIFIER .)
    AND_OP          reduce using rule 59 (literal -> IDENTIFIER .)
    INTEGER         reduce using rule 59 (literal -> IDENTIFIER .)
    STRING          reduce using rule 59 (literal -> IDENTIFIER .)
    TRUE            reduce using rule 59 (literal -> IDENTIFIER .)
    FALSE           reduce using rule 59 (literal -> IDENTIFIER .)
    $end            reduce using rule 59 (literal -> IDENTIFIER .)
    RCURLY          reduce using rule 59 (literal -> IDENTIFIER .)


state 63

    (32) conjunction -> AND_OP equality .

    OR_OP           reduce using rule 32 (conjunction -> AND_OP equality .)
    VAR             reduce using rule 32 (conjunction -> AND_OP equality .)
    LET             reduce using rule 32 (conjunction -> AND_OP equality .)
    IDENTIFIER      reduce using rule 32 (conjunction -> AND_OP equality .)
    PRINT           reduce using rule 32 (conjunction -> AND_OP equality .)
    IF              reduce using rule 32 (conjunction -> AND_OP equality .)
    AND_OP          reduce using rule 32 (conjunction -> AND_OP equality .)
    INTEGER         reduce using rule 32 (conjunction -> AND_OP equality .)
    STRING          reduce using rule 32 (conjunction -> AND_OP equality .)
    TRUE            reduce using rule 32 (conjunction -> AND_OP equality .)
    FALSE           reduce using rule 32 (conjunction -> AND_OP equality .)
    $end            reduce using rule 32 (conjunction -> AND_OP equality .)
    RCURLY          reduce using rule 32 (conjunction -> AND_OP equality .)


state 64

    (9) print -> PRINT LPAREN RPAREN .

    VAR             reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    LET             reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    PRINT           reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    AND_OP          reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    INTEGER         reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    STRING          reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    TRUE            reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    FALSE           reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 9 (print -> PRINT LPAREN RPAREN .)
    RCURLY          reduce using rule 9 (print -> PRINT LPAREN RPAREN .)


state 65

    (13) print -> PRINT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 87


state 66

    (10) print -> PRINT LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 88


state 67

    (12) print -> PRINT LPAREN decimal . RPAREN

    RPAREN          shift and go to state 89


state 68

    (11) print -> PRINT LPAREN INTEGER . RPAREN
    (66) decimal -> INTEGER . . INTEGER

    RPAREN          shift and go to state 90
    .               shift and go to state 55


state 69

    (19) variableDeclaration -> VAR IDENTIFIER EQUALS . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 91
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 70

    (36) equality -> relation eqOP equality .

    OR_OP           reduce using rule 36 (equality -> relation eqOP equality .)
    VAR             reduce using rule 36 (equality -> relation eqOP equality .)
    LET             reduce using rule 36 (equality -> relation eqOP equality .)
    IDENTIFIER      reduce using rule 36 (equality -> relation eqOP equality .)
    PRINT           reduce using rule 36 (equality -> relation eqOP equality .)
    IF              reduce using rule 36 (equality -> relation eqOP equality .)
    AND_OP          reduce using rule 36 (equality -> relation eqOP equality .)
    INTEGER         reduce using rule 36 (equality -> relation eqOP equality .)
    STRING          reduce using rule 36 (equality -> relation eqOP equality .)
    TRUE            reduce using rule 36 (equality -> relation eqOP equality .)
    FALSE           reduce using rule 36 (equality -> relation eqOP equality .)
    $end            reduce using rule 36 (equality -> relation eqOP equality .)
    RCURLY          reduce using rule 36 (equality -> relation eqOP equality .)


state 71

    (30) expression -> conjunction OR_OP expression .

    VAR             reduce using rule 30 (expression -> conjunction OR_OP expression .)
    LET             reduce using rule 30 (expression -> conjunction OR_OP expression .)
    IDENTIFIER      reduce using rule 30 (expression -> conjunction OR_OP expression .)
    PRINT           reduce using rule 30 (expression -> conjunction OR_OP expression .)
    IF              reduce using rule 30 (expression -> conjunction OR_OP expression .)
    AND_OP          reduce using rule 30 (expression -> conjunction OR_OP expression .)
    INTEGER         reduce using rule 30 (expression -> conjunction OR_OP expression .)
    STRING          reduce using rule 30 (expression -> conjunction OR_OP expression .)
    TRUE            reduce using rule 30 (expression -> conjunction OR_OP expression .)
    FALSE           reduce using rule 30 (expression -> conjunction OR_OP expression .)
    $end            reduce using rule 30 (expression -> conjunction OR_OP expression .)
    RCURLY          reduce using rule 30 (expression -> conjunction OR_OP expression .)


state 72

    (46) addition -> term addOP addition .

    LT_OP           reduce using rule 46 (addition -> term addOP addition .)
    LE_OP           reduce using rule 46 (addition -> term addOP addition .)
    GT_OP           reduce using rule 46 (addition -> term addOP addition .)
    GE_OP           reduce using rule 46 (addition -> term addOP addition .)
    EQ_OP           reduce using rule 46 (addition -> term addOP addition .)
    NE_OP           reduce using rule 46 (addition -> term addOP addition .)
    OR_OP           reduce using rule 46 (addition -> term addOP addition .)
    VAR             reduce using rule 46 (addition -> term addOP addition .)
    LET             reduce using rule 46 (addition -> term addOP addition .)
    IDENTIFIER      reduce using rule 46 (addition -> term addOP addition .)
    PRINT           reduce using rule 46 (addition -> term addOP addition .)
    IF              reduce using rule 46 (addition -> term addOP addition .)
    AND_OP          reduce using rule 46 (addition -> term addOP addition .)
    INTEGER         reduce using rule 46 (addition -> term addOP addition .)
    STRING          reduce using rule 46 (addition -> term addOP addition .)
    TRUE            reduce using rule 46 (addition -> term addOP addition .)
    FALSE           reduce using rule 46 (addition -> term addOP addition .)
    $end            reduce using rule 46 (addition -> term addOP addition .)
    RCURLY          reduce using rule 46 (addition -> term addOP addition .)


state 73

    (14) variableReassignment -> IDENTIFIER EQUALS expression .

    RCURLY          reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    VAR             reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    LET             reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    IDENTIFIER      reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    PRINT           reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    IF              reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    AND_OP          reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    INTEGER         reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    STRING          reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    TRUE            reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    FALSE           reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)
    $end            reduce using rule 14 (variableReassignment -> IDENTIFIER EQUALS expression .)


state 74

    (17) variableReassignment -> IDENTIFIER MUEQ expression .

    RCURLY          reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    VAR             reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    LET             reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    IDENTIFIER      reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    PRINT           reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    IF              reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    AND_OP          reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    INTEGER         reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    STRING          reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    TRUE            reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    FALSE           reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)
    $end            reduce using rule 17 (variableReassignment -> IDENTIFIER MUEQ expression .)


state 75

    (18) variableReassignment -> IDENTIFIER DEQ expression .

    RCURLY          reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    VAR             reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    LET             reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    IDENTIFIER      reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    PRINT           reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    IF              reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    AND_OP          reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    INTEGER         reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    STRING          reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    TRUE            reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    FALSE           reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)
    $end            reduce using rule 18 (variableReassignment -> IDENTIFIER DEQ expression .)


state 76

    (16) variableReassignment -> IDENTIFIER MEQ expression .

    RCURLY          reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    VAR             reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    LET             reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    IDENTIFIER      reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    PRINT           reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    IF              reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    AND_OP          reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    INTEGER         reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    STRING          reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    TRUE            reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    FALSE           reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)
    $end            reduce using rule 16 (variableReassignment -> IDENTIFIER MEQ expression .)


state 77

    (15) variableReassignment -> IDENTIFIER PEQ expression .

    RCURLY          reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    VAR             reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    LET             reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    IDENTIFIER      reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    PRINT           reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    IF              reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    AND_OP          reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    INTEGER         reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    STRING          reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    TRUE            reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    FALSE           reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)
    $end            reduce using rule 15 (variableReassignment -> IDENTIFIER PEQ expression .)


state 78

    (50) term -> factor mulOP term .

    PLUS            reduce using rule 50 (term -> factor mulOP term .)
    MINUS           reduce using rule 50 (term -> factor mulOP term .)
    LT_OP           reduce using rule 50 (term -> factor mulOP term .)
    LE_OP           reduce using rule 50 (term -> factor mulOP term .)
    GT_OP           reduce using rule 50 (term -> factor mulOP term .)
    GE_OP           reduce using rule 50 (term -> factor mulOP term .)
    EQ_OP           reduce using rule 50 (term -> factor mulOP term .)
    NE_OP           reduce using rule 50 (term -> factor mulOP term .)
    OR_OP           reduce using rule 50 (term -> factor mulOP term .)
    VAR             reduce using rule 50 (term -> factor mulOP term .)
    LET             reduce using rule 50 (term -> factor mulOP term .)
    IDENTIFIER      reduce using rule 50 (term -> factor mulOP term .)
    PRINT           reduce using rule 50 (term -> factor mulOP term .)
    IF              reduce using rule 50 (term -> factor mulOP term .)
    AND_OP          reduce using rule 50 (term -> factor mulOP term .)
    INTEGER         reduce using rule 50 (term -> factor mulOP term .)
    STRING          reduce using rule 50 (term -> factor mulOP term .)
    TRUE            reduce using rule 50 (term -> factor mulOP term .)
    FALSE           reduce using rule 50 (term -> factor mulOP term .)
    $end            reduce using rule 50 (term -> factor mulOP term .)
    RCURLY          reduce using rule 50 (term -> factor mulOP term .)


state 79

    (25) codeBlock -> LCURLY . statements RCURLY
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . expression
    (5) statement -> . variableDeclaration
    (6) statement -> . variableReassignment
    (7) statement -> . print
    (8) statement -> . ifStatement
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (19) variableDeclaration -> . VAR IDENTIFIER EQUALS expression
    (20) variableDeclaration -> . LET IDENTIFIER EQUALS expression
    (14) variableReassignment -> . IDENTIFIER EQUALS expression
    (15) variableReassignment -> . IDENTIFIER PEQ expression
    (16) variableReassignment -> . IDENTIFIER MEQ expression
    (17) variableReassignment -> . IDENTIFIER MUEQ expression
    (18) variableReassignment -> . IDENTIFIER DEQ expression
    (9) print -> . PRINT LPAREN RPAREN
    (10) print -> . PRINT LPAREN IDENTIFIER RPAREN
    (11) print -> . PRINT LPAREN INTEGER RPAREN
    (12) print -> . PRINT LPAREN decimal RPAREN
    (13) print -> . PRINT LPAREN STRING RPAREN
    (21) ifStatement -> . IF conditionalStatement codeBlock
    (22) ifStatement -> . IF conditionalStatement codeBlock elseStatement
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    VAR             shift and go to state 3
    LET             shift and go to state 23
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 1
    IF              shift and go to state 13
    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    variableReassignment           shift and go to state 2
    expression                     shift and go to state 17
    statements                     shift and go to state 92
    ifStatement                    shift and go to state 19
    variableDeclaration            shift and go to state 20
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    print                          shift and go to state 21
    conjunction                    shift and go to state 8
    statement                      shift and go to state 9
    term                           shift and go to state 10
    decimal                        shift and go to state 25
    factor                         shift and go to state 12
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 80

    (21) ifStatement -> IF conditionalStatement codeBlock .
    (22) ifStatement -> IF conditionalStatement codeBlock . elseStatement
    (23) elseStatement -> . ELSE codeBlock
    (24) elseStatement -> . ifStatement
    (21) ifStatement -> . IF conditionalStatement codeBlock
    (22) ifStatement -> . IF conditionalStatement codeBlock elseStatement

  ! shift/reduce conflict for IF resolved as shift
    VAR             reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    LET             reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    IDENTIFIER      reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    PRINT           reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    AND_OP          reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    INTEGER         reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    STRING          reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    TRUE            reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    FALSE           reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    $end            reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    RCURLY          reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .)
    ELSE            shift and go to state 95
    IF              shift and go to state 13

  ! IF              [ reduce using rule 21 (ifStatement -> IF conditionalStatement codeBlock .) ]

    ifStatement                    shift and go to state 93
    elseStatement                  shift and go to state 94

state 81

    (26) conditionalStatement -> item boolOP . item
    (62) item -> . INTEGER
    (63) item -> . IDENTIFIER
    (64) item -> . STRING
    (65) item -> . decimal
    (66) decimal -> . INTEGER . INTEGER

    INTEGER         shift and go to state 54
    IDENTIFIER      shift and go to state 52
    STRING          shift and go to state 50

    item                           shift and go to state 96
    decimal                        shift and go to state 53

state 82

    (33) boolOP -> eqOP .

    INTEGER         reduce using rule 33 (boolOP -> eqOP .)
    IDENTIFIER      reduce using rule 33 (boolOP -> eqOP .)
    STRING          reduce using rule 33 (boolOP -> eqOP .)


state 83

    (34) boolOP -> relOP .

    INTEGER         reduce using rule 34 (boolOP -> relOP .)
    IDENTIFIER      reduce using rule 34 (boolOP -> relOP .)
    STRING          reduce using rule 34 (boolOP -> relOP .)


state 84

    (66) decimal -> INTEGER . INTEGER .

    MULT            reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    DIV             reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    MOD             reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    PLUS            reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    MINUS           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    LT_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    LE_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    GT_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    GE_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    EQ_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    NE_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    OR_OP           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    VAR             reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    LET             reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    IDENTIFIER      reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    PRINT           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    IF              reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    AND_OP          reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    INTEGER         reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    STRING          reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    TRUE            reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    FALSE           reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    $end            reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    RCURLY          reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    LCURLY          reduce using rule 66 (decimal -> INTEGER . INTEGER .)
    RPAREN          reduce using rule 66 (decimal -> INTEGER . INTEGER .)


state 85

    (40) relation -> addition relOP relation .

    EQ_OP           reduce using rule 40 (relation -> addition relOP relation .)
    NE_OP           reduce using rule 40 (relation -> addition relOP relation .)
    OR_OP           reduce using rule 40 (relation -> addition relOP relation .)
    VAR             reduce using rule 40 (relation -> addition relOP relation .)
    LET             reduce using rule 40 (relation -> addition relOP relation .)
    IDENTIFIER      reduce using rule 40 (relation -> addition relOP relation .)
    PRINT           reduce using rule 40 (relation -> addition relOP relation .)
    IF              reduce using rule 40 (relation -> addition relOP relation .)
    AND_OP          reduce using rule 40 (relation -> addition relOP relation .)
    INTEGER         reduce using rule 40 (relation -> addition relOP relation .)
    STRING          reduce using rule 40 (relation -> addition relOP relation .)
    TRUE            reduce using rule 40 (relation -> addition relOP relation .)
    FALSE           reduce using rule 40 (relation -> addition relOP relation .)
    $end            reduce using rule 40 (relation -> addition relOP relation .)
    RCURLY          reduce using rule 40 (relation -> addition relOP relation .)


state 86

    (20) variableDeclaration -> LET IDENTIFIER EQUALS . expression
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    IDENTIFIER      shift and go to state 62
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    expression                     shift and go to state 97
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    conjunction                    shift and go to state 8
    term                           shift and go to state 10
    factor                         shift and go to state 12
    decimal                        shift and go to state 25
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 87

    (13) print -> PRINT LPAREN STRING RPAREN .

    VAR             reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    LET             reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    IDENTIFIER      reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    IF              reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    AND_OP          reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    INTEGER         reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    STRING          reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    TRUE            reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    FALSE           reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    $end            reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)
    RCURLY          reduce using rule 13 (print -> PRINT LPAREN STRING RPAREN .)


state 88

    (10) print -> PRINT LPAREN IDENTIFIER RPAREN .

    VAR             reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    LET             reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    IDENTIFIER      reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    PRINT           reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    IF              reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    AND_OP          reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    INTEGER         reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    STRING          reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    TRUE            reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    FALSE           reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    $end            reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)
    RCURLY          reduce using rule 10 (print -> PRINT LPAREN IDENTIFIER RPAREN .)


state 89

    (12) print -> PRINT LPAREN decimal RPAREN .

    VAR             reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    LET             reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    IDENTIFIER      reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    PRINT           reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    IF              reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    AND_OP          reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    INTEGER         reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    STRING          reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    TRUE            reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    FALSE           reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    $end            reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)
    RCURLY          reduce using rule 12 (print -> PRINT LPAREN decimal RPAREN .)


state 90

    (11) print -> PRINT LPAREN INTEGER RPAREN .

    VAR             reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    LET             reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    IDENTIFIER      reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    PRINT           reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    IF              reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    AND_OP          reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    INTEGER         reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    STRING          reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    TRUE            reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    FALSE           reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    $end            reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)
    RCURLY          reduce using rule 11 (print -> PRINT LPAREN INTEGER RPAREN .)


state 91

    (19) variableDeclaration -> VAR IDENTIFIER EQUALS expression .

    VAR             reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    LET             reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    IDENTIFIER      reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    PRINT           reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    IF              reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    AND_OP          reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    INTEGER         reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    STRING          reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    TRUE            reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    FALSE           reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    $end            reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)
    RCURLY          reduce using rule 19 (variableDeclaration -> VAR IDENTIFIER EQUALS expression .)


state 92

    (25) codeBlock -> LCURLY statements . RCURLY
    (3) statements -> statements . statement
    (4) statement -> . expression
    (5) statement -> . variableDeclaration
    (6) statement -> . variableReassignment
    (7) statement -> . print
    (8) statement -> . ifStatement
    (29) expression -> . conjunction
    (30) expression -> . conjunction OR_OP expression
    (19) variableDeclaration -> . VAR IDENTIFIER EQUALS expression
    (20) variableDeclaration -> . LET IDENTIFIER EQUALS expression
    (14) variableReassignment -> . IDENTIFIER EQUALS expression
    (15) variableReassignment -> . IDENTIFIER PEQ expression
    (16) variableReassignment -> . IDENTIFIER MEQ expression
    (17) variableReassignment -> . IDENTIFIER MUEQ expression
    (18) variableReassignment -> . IDENTIFIER DEQ expression
    (9) print -> . PRINT LPAREN RPAREN
    (10) print -> . PRINT LPAREN IDENTIFIER RPAREN
    (11) print -> . PRINT LPAREN INTEGER RPAREN
    (12) print -> . PRINT LPAREN decimal RPAREN
    (13) print -> . PRINT LPAREN STRING RPAREN
    (21) ifStatement -> . IF conditionalStatement codeBlock
    (22) ifStatement -> . IF conditionalStatement codeBlock elseStatement
    (31) conjunction -> . equality
    (32) conjunction -> . AND_OP equality
    (35) equality -> . relation
    (36) equality -> . relation eqOP equality
    (39) relation -> . addition
    (40) relation -> . addition relOP relation
    (45) addition -> . term
    (46) addition -> . term addOP addition
    (49) term -> . factor
    (50) term -> . factor mulOP term
    (54) factor -> . primary
    (55) primary -> . literal
    (56) literal -> . INTEGER
    (57) literal -> . decimal
    (58) literal -> . STRING
    (59) literal -> . IDENTIFIER
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (66) decimal -> . INTEGER . INTEGER

    RCURLY          shift and go to state 98
    VAR             shift and go to state 3
    LET             shift and go to state 23
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 1
    IF              shift and go to state 13
    AND_OP          shift and go to state 26
    INTEGER         shift and go to state 15
    STRING          shift and go to state 22
    TRUE            shift and go to state 18
    FALSE           shift and go to state 24

    variableReassignment           shift and go to state 2
    expression                     shift and go to state 17
    ifStatement                    shift and go to state 19
    variableDeclaration            shift and go to state 20
    relation                       shift and go to state 6
    literal                        shift and go to state 7
    print                          shift and go to state 21
    conjunction                    shift and go to state 8
    statement                      shift and go to state 30
    term                           shift and go to state 10
    decimal                        shift and go to state 25
    factor                         shift and go to state 12
    equality                       shift and go to state 14
    addition                       shift and go to state 16
    primary                        shift and go to state 27

state 93

    (24) elseStatement -> ifStatement .

    VAR             reduce using rule 24 (elseStatement -> ifStatement .)
    LET             reduce using rule 24 (elseStatement -> ifStatement .)
    IDENTIFIER      reduce using rule 24 (elseStatement -> ifStatement .)
    PRINT           reduce using rule 24 (elseStatement -> ifStatement .)
    IF              reduce using rule 24 (elseStatement -> ifStatement .)
    AND_OP          reduce using rule 24 (elseStatement -> ifStatement .)
    INTEGER         reduce using rule 24 (elseStatement -> ifStatement .)
    STRING          reduce using rule 24 (elseStatement -> ifStatement .)
    TRUE            reduce using rule 24 (elseStatement -> ifStatement .)
    FALSE           reduce using rule 24 (elseStatement -> ifStatement .)
    $end            reduce using rule 24 (elseStatement -> ifStatement .)
    RCURLY          reduce using rule 24 (elseStatement -> ifStatement .)


state 94

    (22) ifStatement -> IF conditionalStatement codeBlock elseStatement .

    VAR             reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    LET             reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    IDENTIFIER      reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    PRINT           reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    IF              reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    AND_OP          reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    INTEGER         reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    STRING          reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    TRUE            reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    FALSE           reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    $end            reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)
    RCURLY          reduce using rule 22 (ifStatement -> IF conditionalStatement codeBlock elseStatement .)


state 95

    (23) elseStatement -> ELSE . codeBlock
    (25) codeBlock -> . LCURLY statements RCURLY

    LCURLY          shift and go to state 79

    codeBlock                      shift and go to state 99

state 96

    (26) conditionalStatement -> item boolOP item .

    LCURLY          reduce using rule 26 (conditionalStatement -> item boolOP item .)


state 97

    (20) variableDeclaration -> LET IDENTIFIER EQUALS expression .

    VAR             reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    LET             reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    IDENTIFIER      reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    PRINT           reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    IF              reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    AND_OP          reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    INTEGER         reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    STRING          reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    TRUE            reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    FALSE           reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    $end            reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)
    RCURLY          reduce using rule 20 (variableDeclaration -> LET IDENTIFIER EQUALS expression .)


state 98

    (25) codeBlock -> LCURLY statements RCURLY .

    ELSE            reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    IF              reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    VAR             reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    LET             reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    IDENTIFIER      reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    PRINT           reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    AND_OP          reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    INTEGER         reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    STRING          reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    TRUE            reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    FALSE           reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    $end            reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)
    RCURLY          reduce using rule 25 (codeBlock -> LCURLY statements RCURLY .)


state 99

    (23) elseStatement -> ELSE codeBlock .

    VAR             reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    LET             reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    IDENTIFIER      reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    PRINT           reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    IF              reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    AND_OP          reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    INTEGER         reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    STRING          reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    TRUE            reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    FALSE           reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    $end            reduce using rule 23 (elseStatement -> ELSE codeBlock .)
    RCURLY          reduce using rule 23 (elseStatement -> ELSE codeBlock .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
